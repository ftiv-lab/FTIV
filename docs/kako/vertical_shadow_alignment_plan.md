# 縦書き影ズレ修正プラン (Vertical Shadow Alignment Plan)

## 現象と原因詳細 (High Resolution Analysis)

ユーザー様より提供された情報（オフセット0でも縦書きの影がズレる）を分析した結果、根本原因を特定しました。

### 原因: 独立したレイアウト計算 (Independent Layout Calculation)

現在の `_draw_vertical_text_content` 関数は、渡された `painter` にセットされているフォント（影ならShadow Font）を使って、「文字の高さ (`fm.height`)」や「中心位置 (`cy`)」を再計算しています。

たとえ影のサイズ倍率が 1.0 であっても、以下の理由で「メインテキスト」と「影」の計算結果に微細な差異が生じます：
1.  **フォントレンダリングのヒンティング**: 描画色や設定が異なると、OSのフォントエンジンが返すメトリクス（Ascent/Descent）が1px単位で変わることがある。
2.  **`_get_vertical_char_transform` の再計算**: 文字ごとの回転やオフセット(`dx, dy`)も影フォントで再計算されるため、ここでもズレが生じる。

この「レイアウトの再計算」が、文字数が重なるごとに誤差を蓄積させ（ドリフト）、目に見える「ズレ」となります。

## 改善策: レイアウト・ロッキング (Layout Locking)

この問題を解決する唯一かつ確実な方法は、**「影の描画時も、座標計算にはメインテキストのフォントを使う」** ことです。

### 実装プラン

1.  **`_draw_vertical_text_content` のシグネチャ変更**
    *   `layout_font: Optional[QFont] = None` 引数を追加します。

2.  **計算ロジックの修正**
    *   座標計算（`fm`の取得、`step`の計算、`_get_vertical_char_transform`の呼び出し）には、`painter.font()` ではなく、渡された `layout_font` （指定がなければ `painter.font()`）を使用します。
    *   `painter.drawText` や `drawPath` などの**描画**には、そのまま `painter.font()`（影フォント）を使用します。

3.  **呼び出し元の修正 (`_draw_vertical_text_elements`)**
    *   メインの `font` を取得しておきます。
    *   影（Shadow）と縁取り（Outline）を描画する際、この `font` を `layout_font` として渡します。

これにより、影や縁取りは、**メインテキストと全く同じ「枠」の中に描画されることが数学的に保証**されます。
オフセットが(0,0)であれば、すべてのピクセルが完全に重なり、ズレは100%解消します。

## メリット

*   **完全な一致**: フォントサイズや種類に関わらず、装飾レイヤーが本体と完全に同期します。
*   **低リスク**: ロジック自体を大きく書き換えるのではなく、「基準とする定規（フォント）」を変えるだけなので、副作用のリスクが極めて低いです。
