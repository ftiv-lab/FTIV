# 影とレンダリングの抜本的改善案: レイアウト主導パイプライン (Layout-Driven Pipeline)

現在の実装における「修正を重ねてきた」感覚は、**「レンダリング（描画）しながらサイズを辻褄合わせしている」** というアーキテクチャの構造的限界から来ています。
ご指摘の通り、これを根本的に解決するには、処理の流れを再構築する「レイアウト主導」のアプローチが最適です。

## 1. 現状の課題：リアクティブ（事後対応）なサイズ計算

現在の `text_renderer.py` は以下のような構造になっています：

1.  **概算サイズ計算**: フォントサイズと文字数から「だいたいこれくらい」のキャンバスサイズを計算。
2.  **描画処理**: そのキャンバスに描画。
3.  **問題発生**: 「影がはみ出した」「縦書きで幅広の文字が切れた」。
4.  **パッチ修正**: 「サイズ計算にマージンを足す」「文字幅をチェックする処理を追加する」。

この方式では、新しいエフェクト（例：光彩、極太の縁取り）を追加するたびに、サイズ計算ロジックに「つぎはぎ」の修正が必要になります。

## 2. 根本的改善案：レイアウト主導（Measure First, Draw Once）

「描画する前に、すべての配置とサイズを確定させる」アーキテクチャへ移行します。
処理を大きく3つのフェーズに分離します。

### Phase 1: レイアウト計算 (Text Layout Engine)
*   **役割**: 「どこに」「どの文字を」「どう回転させて」置くかを決定する。色や影は無視。
*   **出力**: `ComputedLayout` オブジェクト
    *   `glyph_positions`: 各文字の正確な座標と回転角のリスト。
    *   `content_rect`: 文字列全体が収まる最小の矩形（Tight Bounding Box）。

### Phase 2: エフェクト境界計算 (Effect Bounds Manager)
*   **役割**: レイアウト（コンテンツ）に対し、有効なエフェクト（影、縁取り、ぼかし）が「どれだけはみ出すか」を数学的に計算する。
*   **ロジック**:
    *   `shadow_rect` = `content_rect` をオフセット分ずらし、ぼかし半径分上下左右に拡張。
    *   `outline_rect` = `content_rect` を縁取り幅分拡張。
    *   `final_canvas_rect` = すべての矩形を包含する矩形（Union Rect）。
*   **メリット**: これにより、**「見切れ」が数学的にあり得なくなります**。どんなに影を離しても、キャンバスが自動的にそれを包含するサイズになります。

### Phase 3: レンダリング (Stateless Renderer)
*   **役割**: 計算済みの `ComputedLayout` と `final_canvas_rect` に従って描画するだけ。
*   **変更点**: 描画時に座標計算を行いません。Phase 1 で計算された座標に従って `drawText` するだけです。

## 3. 期待される効果

1.  **「見切れ」の根絶**:
    影のオフセット、ぼかし半径、文字の特殊な幅（薔薇など）がすべて Phase 1 & 2 で計算に含まれるため、キャンバスサイズ不足による見切れが原理的に発生しなくなります。
2.  **修正の局所化**:
    *   「文字の間隔がおかしい」→ Phase 1 (Layout) だけを見れば直る。
    *   「影が切れている」→ Phase 2 (Bounds) だけを見れば直る。
    *   以前のように、サイズ計算と描画ロジックの両方を修正して同期させる必要がなくなります。
3.  **パフォーマンス向上**:
    同じ座標計算を描画（メイン、影、縁取り×N）のたびに繰り返す無駄がなくなります。

## 4. 移行へのロードマップ

一気に書き換えるのはリスクが高いため、段階的なリファクタリングを提案します。

1.  **Step 1（現在提案中のプラン）**: とりあえず Phase 2 のロジック（厳密なバウンディングボックス計算）を現在の関数内に「関数」として実装し、見切れを防ぐ。
2.  **Step 2**: 縦書き・横書きの座標計算ロジックを `_calculate_layout(window)` として切り出す。
3.  **Step 3**: レンダリングループを、計算済みレイアウトを受け取る形に変更する。

まずは **Step 1（現在の修正プラン）** で目前の「影」問題を解決し、その後、安定稼働を確認しながら Step 2 以降のアーキテクチャ刷新へ進むのが、「Super Senior」として推奨する安全なルートです。
